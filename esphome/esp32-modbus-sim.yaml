substitutions:
  devicename: dsmr_sdm630_emulator
  friendly_name: "DSMR SDM630 Emulator"
  modbus_slave_id: "2"          # SDM630 v2 is commonly expected at address 2 :contentReference[oaicite:3]{index=3}
  modbus_baud: "9600"

  # UART pins (adjust to your ESP32-S3 + RS485 module)
  uart_tx_pin: GPIO17
  uart_rx_pin: GPIO18

  # Optional RS485 direction pins (ONLY if your RS485 module needs them)
  # Leave empty/comment out if you have auto-direction RS485.
  rs485_de_pin: GPIO16
  rs485_re_pin: GPIO15

  # If your HA power sensors are in kW, set to 1000.0; if already W, keep 1.0
  power_unit_factor_to_w: "1.0"

  # Whether to clamp currents to positive (recommended for “house load” style meters)
  clamp_current_to_positive: "true"

  # ---- Home Assistant entities (from DSMR P1) ----
  ha_v_l1: sensor.voltage_phase_1
  ha_v_l2: sensor.voltage_phase_2
  ha_v_l3: sensor.voltage_phase_3

  ha_i_l1: sensor.current_phase_1
  ha_i_l2: sensor.current_phase_2
  ha_i_l3: sensor.current_phase_3

  # If you have per-phase consumed & produced power:
  ha_p_cons_l1: sensor.power_consumed_l1
  ha_p_cons_l2: sensor.power_consumed_l2
  ha_p_cons_l3: sensor.power_consumed_l3
  ha_p_prod_l1: sensor.power_produced_l1
  ha_p_prod_l2: sensor.power_produced_l2
  ha_p_prod_l3: sensor.power_produced_l3

  # Total import energy (kWh). Use what you have available in HA.
  # Many DSMR integrations expose cumulative import/export totals.
  ha_e_import_total: sensor.energy_import_total
  ha_e_export_total: sensor.energy_export_total

  # Frequency (optional; if you have it, set entity; else keep empty and we’ll use 50Hz)
  ha_freq: sensor.grid_frequency

esphome:
  name: ${devicename}
  friendly_name: ${friendly_name}
  min_version: 2025.3.3

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

logger:
  level: INFO
  baud_rate: 0

api:
ota:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: none

# Use the repo’s modbus_server component (instead of Shelly code). :contentReference[oaicite:4]{index=4}
external_components:
  - source: github://ReneWerner87/esphome-fake-eastron-SDM630-Shelly-3EM-ESPHome@master
    refresh: 60s
    components: [modbus_server]

uart:
  - id: intmodbus
    tx_pin: ${uart_tx_pin}
    rx_pin: ${uart_rx_pin}
    baud_rate: ${modbus_baud}
    stop_bits: 1
    data_bits: 8
    parity: NONE

# Modbus slave with SDM630-style INPUT registers
modbus_server:
  - id: modbusserver
    uart_id: intmodbus
    address: ${modbus_slave_id}

    # If your RS485 module needs DE/RE control, uncomment these (repo supports it in practice)
    # de_pin: ${rs485_de_pin}
    # re_pin: ${rs485_re_pin}

    # SDM630 V2 uses input registers (FC04) for measurements; the sample allocates a block. :contentReference[oaicite:5]{index=5}
    input_registers:
      - start_address: 0x0000
        default: 0
        number: 72
        on_read: |-
          // Keep it simple: serve stored register values.
          return value;

      # Optional "invalid access" range like the sample (helps debugging some masters). :contentReference[oaicite:6]{index=6}
      - start_address: 0x00C8
        default: 0
        number: 6
        on_read: |-
          return value;

sensor:
  # --- HA raw sensors ---
  - platform: homeassistant
    id: ha_v_l1
    entity_id: ${ha_v_l1}
    internal: true
  - platform: homeassistant
    id: ha_v_l2
    entity_id: ${ha_v_l2}
    internal: true
  - platform: homeassistant
    id: ha_v_l3
    entity_id: ${ha_v_l3}
    internal: true

  - platform: homeassistant
    id: ha_i_l1
    entity_id: ${ha_i_l1}
    internal: true
  - platform: homeassistant
    id: ha_i_l2
    entity_id: ${ha_i_l2}
    internal: true
  - platform: homeassistant
    id: ha_i_l3
    entity_id: ${ha_i_l3}
    internal: true

  - platform: homeassistant
    id: ha_p_cons_l1
    entity_id: ${ha_p_cons_l1}
    internal: true
  - platform: homeassistant
    id: ha_p_cons_l2
    entity_id: ${ha_p_cons_l2}
    internal: true
  - platform: homeassistant
    id: ha_p_cons_l3
    entity_id: ${ha_p_cons_l3}
    internal: true

  - platform: homeassistant
    id: ha_p_prod_l1
    entity_id: ${ha_p_prod_l1}
    internal: true
  - platform: homeassistant
    id: ha_p_prod_l2
    entity_id: ${ha_p_prod_l2}
    internal: true
  - platform: homeassistant
    id: ha_p_prod_l3
    entity_id: ${ha_p_prod_l3}
    internal: true

  - platform: homeassistant
    id: ha_e_import_total
    entity_id: ${ha_e_import_total}
    internal: true
  - platform: homeassistant
    id: ha_e_export_total
    entity_id: ${ha_e_export_total}
    internal: true

  # Frequency is optional. If entity doesn’t exist, it will be NAN -> we fall back to 50.0
  - platform: homeassistant
    id: ha_freq
    entity_id: ${ha_freq}
    internal: true

  # --- Derived net power per phase (W) ---
  - platform: template
    id: p_net_l1_w
    internal: true
    update_interval: 1s
    lambda: |-
      const float k = ${power_unit_factor_to_w};
      float cons = id(ha_p_cons_l1).has_state() ? id(ha_p_cons_l1).state * k : 0.0f;
      float prod = id(ha_p_prod_l1).has_state() ? id(ha_p_prod_l1).state * k : 0.0f;
      return cons - prod;

  - platform: template
    id: p_net_l2_w
    internal: true
    update_interval: 1s
    lambda: |-
      const float k = ${power_unit_factor_to_w};
      float cons = id(ha_p_cons_l2).has_state() ? id(ha_p_cons_l2).state * k : 0.0f;
      float prod = id(ha_p_prod_l2).has_state() ? id(ha_p_prod_l2).state * k : 0.0f;
      return cons - prod;

  - platform: template
    id: p_net_l3_w
    internal: true
    update_interval: 1s
    lambda: |-
      const float k = ${power_unit_factor_to_w};
      float cons = id(ha_p_cons_l3).has_state() ? id(ha_p_cons_l3).state * k : 0.0f;
      float prod = id(ha_p_prod_l3).has_state() ? id(ha_p_prod_l3).state * k : 0.0f;
      return cons - prod;

  - platform: template
    id: p_total_w
    internal: true
    update_interval: 1s
    lambda: |-
      return id(p_net_l1_w).state + id(p_net_l2_w).state + id(p_net_l3_w).state;

  # --- Currents to expose (A), direct from DSMR ---
  - platform: template
    id: i_l1_a
    internal: true
    update_interval: 1s
    lambda: |-
      float i = id(ha_i_l1).has_state() ? (float)id(ha_i_l1).state : 0.0f;
      if (${clamp_current_to_positive} && i < 0.0f) i = 0.0f;
      return i;

  - platform: template
    id: i_l2_a
    internal: true
    update_interval: 1s
    lambda: |-
      float i = id(ha_i_l2).has_state() ? (float)id(ha_i_l2).state : 0.0f;
      if (${clamp_current_to_positive} && i < 0.0f) i = 0.0f;
      return i;

  - platform: template
    id: i_l3_a
    internal: true
    update_interval: 1s
    lambda: |-
      float i = id(ha_i_l3).has_state() ? (float)id(ha_i_l3).state : 0.0f;
      if (${clamp_current_to_positive} && i < 0.0f) i = 0.0f;
      return i;

interval:
  # Update Modbus registers once per second (same cadence as the sample Shelly implementation). :contentReference[oaicite:7]{index=7}
  - interval: 1s
    then:
      - lambda: |-
          // SDM630-style: IEEE-754 float packed into 2x16-bit input registers, word-swapped.
          // The sample writes reg[1] then reg[0]. :contentReference[oaicite:8]{index=8}
          union {
            uint16_t reg[2];
            float value;
          } conv;

          auto write_f32 = [&](uint16_t addr, float v) {
            conv.value = v;
            id(modbusserver)->write_input_register(addr,   conv.reg[1]);
            id(modbusserver)->write_input_register(addr+1, conv.reg[0]);
          };

          auto safe = [](esphome::sensor::Sensor *s, float fallback) -> float {
            if (s != nullptr && s->has_state() && !isnan(s->state)) return (float) s->state;
            return fallback;
          };

          // --- Registers used by the sample mapping (subset) ---
          // 0x0000.. : Voltages L1/L2/L3
          write_f32(0x0000, safe(id(ha_v_l1), 230.0f));
          write_f32(0x0002, safe(id(ha_v_l2), 230.0f));
          write_f32(0x0004, safe(id(ha_v_l3), 230.0f));

          // 0x0006.. : Currents L1/L2/L3
          write_f32(0x0006, (float) id(i_l1_a).state);
          write_f32(0x0008, (float) id(i_l2_a).state);
          write_f32(0x000A, (float) id(i_l3_a).state);

          // 0x000C.. : Active power per phase
          write_f32(0x000C, (float) id(p_net_l1_w).state);
          write_f32(0x000E, (float) id(p_net_l2_w).state);
          write_f32(0x0010, (float) id(p_net_l3_w).state);

          // 0x0046 : Frequency
          write_f32(0x0046, safe(id(ha_freq), 50.0f));

          // 0x0156 : Total energy (kWh)
          // The sample provides one "total energy" register (kWh). :contentReference[oaicite:9]{index=9}
          // DSMR has separate import/export totals; SDM630 “total” varies by interpretation.
          // Here: net import kWh = import_total - export_total (never below 0).
          float e_imp = safe(id(ha_e_import_total), 0.0f);
          float e_exp = safe(id(ha_e_export_total), 0.0f);
          float e_net = e_imp - e_exp;
          if (e_net < 0.0f) e_net = 0.0f;
          write_f32(0x0156, e_net);